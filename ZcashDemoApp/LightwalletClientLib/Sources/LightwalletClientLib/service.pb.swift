// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2019-2020 The Zcash developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or https://www.opensource.org/licenses/mit-license.php .

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public enum ShieldedProtocol: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sapling // = 0
    case orchard // = 1
    case UNRECOGNIZED(Int)

    public init() {
        self = .sapling
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sapling
        case 1: self = .orchard
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .sapling: 0
        case .orchard: 1
        case let .UNRECOGNIZED(i): i
        }
    }
}

#if swift(>=4.2)

    extension ShieldedProtocol: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [ShieldedProtocol] = [
            .sapling,
            .orchard,
        ]
    }

#endif // swift(>=4.2)

/// A BlockID message contains identifiers to select a block: a height or a
/// hash. Specification by hash is not implemented, but may be in the future.
public struct BlockID {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var height: UInt64 = 0

    public var hash: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// BlockRange specifies a series of blocks from start to end inclusive.
/// Both BlockIDs must be heights; specification by hash is not yet supported.
public struct BlockRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var start: BlockID {
        get { _start ?? BlockID() }
        set { _start = newValue }
    }

    /// Returns true if `start` has been explicitly set.
    public var hasStart: Bool { _start != nil }
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    public mutating func clearStart() { _start = nil }

    public var end: BlockID {
        get { _end ?? BlockID() }
        set { _end = newValue }
    }

    /// Returns true if `end` has been explicitly set.
    public var hasEnd: Bool { _end != nil }
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    public mutating func clearEnd() { _end = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _start: BlockID?
    fileprivate var _end: BlockID?
}

/// A TxFilter contains the information needed to identify a particular
/// transaction: either a block and an index, or a direct transaction hash.
/// Currently, only specification by hash is supported.
public struct TxFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// block identifier, height or hash
    public var block: BlockID {
        get { _block ?? BlockID() }
        set { _block = newValue }
    }

    /// Returns true if `block` has been explicitly set.
    public var hasBlock: Bool { _block != nil }
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    public mutating func clearBlock() { _block = nil }

    /// index within the block
    public var index: UInt64 = 0

    /// transaction ID (hash, txid)
    public var hash: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _block: BlockID?
}

/// RawTransaction contains the complete transaction data. It also optionally includes
/// the block height in which the transaction was included, or, when returned
/// by GetMempoolStream(), the latest block height.
public struct RawTransaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// exact data returned by Zcash 'getrawtransaction'
    public var data: Data = .init()

    /// height that the transaction was mined (or -1)
    public var height: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// A SendResponse encodes an error code and a string. It is currently used
/// only by SendTransaction(). If error code is zero, the operation was
/// successful; if non-zero, it and the message specify the failure.
public struct SendResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errorCode: Int32 = 0

    public var errorMessage: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Chainspec is a placeholder to allow specification of a particular chain fork.
public struct ChainSpec {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Empty is for gRPCs that take no arguments, currently only GetLightdInfo.
public struct Empty {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// LightdInfo returns various information about this lightwalletd instance
/// and the state of the blockchain.
public struct LightdInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var version: String = .init()

    public var vendor: String = .init()

    /// true
    public var taddrSupport: Bool = false

    /// either "main" or "test"
    public var chainName: String = .init()

    /// depends on mainnet or testnet
    public var saplingActivationHeight: UInt64 = 0

    /// protocol identifier, see consensus/upgrades.cpp
    public var consensusBranchID: String = .init()

    /// latest block on the best chain
    public var blockHeight: UInt64 = 0

    public var gitCommit: String = .init()

    public var branch: String = .init()

    public var buildDate: String = .init()

    public var buildUser: String = .init()

    /// less than tip height if zcashd is syncing
    public var estimatedHeight: UInt64 = 0

    /// example: "v4.1.1-877212414"
    public var zcashdBuild: String = .init()

    /// example: "/MagicBean:4.1.1/"
    public var zcashdSubversion: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// TransparentAddressBlockFilter restricts the results to the given address
/// or block range.
public struct TransparentAddressBlockFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// t-address
    public var address: String = .init()

    /// start, end heights
    public var range: BlockRange {
        get { _range ?? BlockRange() }
        set { _range = newValue }
    }

    /// Returns true if `range` has been explicitly set.
    public var hasRange: Bool { _range != nil }
    /// Clears the value of `range`. Subsequent reads from it will return its default value.
    public mutating func clearRange() { _range = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _range: BlockRange?
}

/// Duration is currently used only for testing, so that the Ping rpc
/// can simulate a delay, to create many simultaneous connections. Units
/// are microseconds.
public struct Duration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var intervalUs: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// PingResponse is used to indicate concurrency, how many Ping rpcs
/// are executing upon entry and upon exit (after the delay).
/// This rpc is used for testing only.
public struct PingResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var entry: Int64 = 0

    public var exit: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Address {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var address: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct AddressList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var addresses: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Balance {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var valueZat: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Exclude {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var txid: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// The TreeState is derived from the Zcash z_gettreestate rpc.
public struct TreeState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// "main" or "test"
    public var network: String = .init()

    /// block height
    public var height: UInt64 = 0

    /// block id
    public var hash: String = .init()

    /// Unix epoch time when the block was mined
    public var time: UInt32 = 0

    /// sapling commitment tree state
    public var saplingTree: String = .init()

    /// orchard commitment tree state
    public var orchardTree: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct GetSubtreeRootsArg {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Index identifying where to start returning subtree roots
    public var startIndex: UInt32 = 0

    /// Shielded protocol to return subtree roots for
    public var shieldedProtocol: ShieldedProtocol = .sapling

    /// Maximum number of entries to return, or 0 for all entries.
    public var maxEntries: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct SubtreeRoot {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The 32-byte Merkle root of the subtree.
    public var rootHash: Data = .init()

    /// The hash of the block that completed this subtree.
    public var completingBlockHash: Data = .init()

    /// The height of the block that completed this subtree in the main chain.
    public var completingBlockHeight: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Results are sorted by height, which makes it easy to issue another
/// request that picks up from where the previous left off.
public struct GetAddressUtxosArg {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var addresses: [String] = []

    public var startHeight: UInt64 = 0

    /// zero means unlimited
    public var maxEntries: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct GetAddressUtxosReply {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var address: String = .init()

    public var txid: Data = .init()

    public var index: Int32 = 0

    public var script: Data = .init()

    public var valueZat: Int64 = 0

    public var height: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct GetAddressUtxosReplyList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var addressUtxos: [GetAddressUtxosReply] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension ShieldedProtocol: @unchecked Sendable {}
    extension BlockID: @unchecked Sendable {}
    extension BlockRange: @unchecked Sendable {}
    extension TxFilter: @unchecked Sendable {}
    extension RawTransaction: @unchecked Sendable {}
    extension SendResponse: @unchecked Sendable {}
    extension ChainSpec: @unchecked Sendable {}
    extension Empty: @unchecked Sendable {}
    extension LightdInfo: @unchecked Sendable {}
    extension TransparentAddressBlockFilter: @unchecked Sendable {}
    extension Duration: @unchecked Sendable {}
    extension PingResponse: @unchecked Sendable {}
    extension Address: @unchecked Sendable {}
    extension AddressList: @unchecked Sendable {}
    extension Balance: @unchecked Sendable {}
    extension Exclude: @unchecked Sendable {}
    extension TreeState: @unchecked Sendable {}
    extension GetSubtreeRootsArg: @unchecked Sendable {}
    extension SubtreeRoot: @unchecked Sendable {}
    extension GetAddressUtxosArg: @unchecked Sendable {}
    extension GetAddressUtxosReply: @unchecked Sendable {}
    extension GetAddressUtxosReplyList: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "cash.z.wallet.sdk.rpc"

extension ShieldedProtocol: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "sapling"),
        1: .same(proto: "orchard"),
    ]
}

extension BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BlockID"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "height"),
        2: .same(proto: "hash"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt64Field(value: &height)
            case 2: try decoder.decodeSingularBytesField(value: &hash)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if height != 0 {
            try visitor.visitSingularUInt64Field(value: height, fieldNumber: 1)
        }
        if !hash.isEmpty {
            try visitor.visitSingularBytesField(value: hash, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: BlockID, rhs: BlockID) -> Bool {
        if lhs.height != rhs.height { return false }
        if lhs.hash != rhs.hash { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension BlockRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BlockRange"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "start"),
        2: .same(proto: "end"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_start)
            case 2: try decoder.decodeSingularMessageField(value: &_end)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _start {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._end {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: BlockRange, rhs: BlockRange) -> Bool {
        if lhs._start != rhs._start { return false }
        if lhs._end != rhs._end { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension TxFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TxFilter"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "block"),
        2: .same(proto: "index"),
        3: .same(proto: "hash"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_block)
            case 2: try decoder.decodeSingularUInt64Field(value: &index)
            case 3: try decoder.decodeSingularBytesField(value: &hash)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _block {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if index != 0 {
            try visitor.visitSingularUInt64Field(value: index, fieldNumber: 2)
        }
        if !hash.isEmpty {
            try visitor.visitSingularBytesField(value: hash, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: TxFilter, rhs: TxFilter) -> Bool {
        if lhs._block != rhs._block { return false }
        if lhs.index != rhs.index { return false }
        if lhs.hash != rhs.hash { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension RawTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RawTransaction"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
        2: .same(proto: "height"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &data)
            case 2: try decoder.decodeSingularUInt64Field(value: &height)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 1)
        }
        if height != 0 {
            try visitor.visitSingularUInt64Field(value: height, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: RawTransaction, rhs: RawTransaction) -> Bool {
        if lhs.data != rhs.data { return false }
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension SendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SendResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "errorCode"),
        2: .same(proto: "errorMessage"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &errorCode)
            case 2: try decoder.decodeSingularStringField(value: &errorMessage)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if errorCode != 0 {
            try visitor.visitSingularInt32Field(value: errorCode, fieldNumber: 1)
        }
        if !errorMessage.isEmpty {
            try visitor.visitSingularStringField(value: errorMessage, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: SendResponse, rhs: SendResponse) -> Bool {
        if lhs.errorCode != rhs.errorCode { return false }
        if lhs.errorMessage != rhs.errorMessage { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension ChainSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ChainSpec"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: ChainSpec, rhs: ChainSpec) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Empty"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Empty, rhs: Empty) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension LightdInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".LightdInfo"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .same(proto: "vendor"),
        3: .same(proto: "taddrSupport"),
        4: .same(proto: "chainName"),
        5: .same(proto: "saplingActivationHeight"),
        6: .same(proto: "consensusBranchId"),
        7: .same(proto: "blockHeight"),
        8: .same(proto: "gitCommit"),
        9: .same(proto: "branch"),
        10: .same(proto: "buildDate"),
        11: .same(proto: "buildUser"),
        12: .same(proto: "estimatedHeight"),
        13: .same(proto: "zcashdBuild"),
        14: .same(proto: "zcashdSubversion"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &version)
            case 2: try decoder.decodeSingularStringField(value: &vendor)
            case 3: try decoder.decodeSingularBoolField(value: &taddrSupport)
            case 4: try decoder.decodeSingularStringField(value: &chainName)
            case 5: try decoder.decodeSingularUInt64Field(value: &saplingActivationHeight)
            case 6: try decoder.decodeSingularStringField(value: &consensusBranchID)
            case 7: try decoder.decodeSingularUInt64Field(value: &blockHeight)
            case 8: try decoder.decodeSingularStringField(value: &gitCommit)
            case 9: try decoder.decodeSingularStringField(value: &branch)
            case 10: try decoder.decodeSingularStringField(value: &buildDate)
            case 11: try decoder.decodeSingularStringField(value: &buildUser)
            case 12: try decoder.decodeSingularUInt64Field(value: &estimatedHeight)
            case 13: try decoder.decodeSingularStringField(value: &zcashdBuild)
            case 14: try decoder.decodeSingularStringField(value: &zcashdSubversion)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !version.isEmpty {
            try visitor.visitSingularStringField(value: version, fieldNumber: 1)
        }
        if !vendor.isEmpty {
            try visitor.visitSingularStringField(value: vendor, fieldNumber: 2)
        }
        if taddrSupport != false {
            try visitor.visitSingularBoolField(value: taddrSupport, fieldNumber: 3)
        }
        if !chainName.isEmpty {
            try visitor.visitSingularStringField(value: chainName, fieldNumber: 4)
        }
        if saplingActivationHeight != 0 {
            try visitor.visitSingularUInt64Field(value: saplingActivationHeight, fieldNumber: 5)
        }
        if !consensusBranchID.isEmpty {
            try visitor.visitSingularStringField(value: consensusBranchID, fieldNumber: 6)
        }
        if blockHeight != 0 {
            try visitor.visitSingularUInt64Field(value: blockHeight, fieldNumber: 7)
        }
        if !gitCommit.isEmpty {
            try visitor.visitSingularStringField(value: gitCommit, fieldNumber: 8)
        }
        if !branch.isEmpty {
            try visitor.visitSingularStringField(value: branch, fieldNumber: 9)
        }
        if !buildDate.isEmpty {
            try visitor.visitSingularStringField(value: buildDate, fieldNumber: 10)
        }
        if !buildUser.isEmpty {
            try visitor.visitSingularStringField(value: buildUser, fieldNumber: 11)
        }
        if estimatedHeight != 0 {
            try visitor.visitSingularUInt64Field(value: estimatedHeight, fieldNumber: 12)
        }
        if !zcashdBuild.isEmpty {
            try visitor.visitSingularStringField(value: zcashdBuild, fieldNumber: 13)
        }
        if !zcashdSubversion.isEmpty {
            try visitor.visitSingularStringField(value: zcashdSubversion, fieldNumber: 14)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: LightdInfo, rhs: LightdInfo) -> Bool {
        if lhs.version != rhs.version { return false }
        if lhs.vendor != rhs.vendor { return false }
        if lhs.taddrSupport != rhs.taddrSupport { return false }
        if lhs.chainName != rhs.chainName { return false }
        if lhs.saplingActivationHeight != rhs.saplingActivationHeight { return false }
        if lhs.consensusBranchID != rhs.consensusBranchID { return false }
        if lhs.blockHeight != rhs.blockHeight { return false }
        if lhs.gitCommit != rhs.gitCommit { return false }
        if lhs.branch != rhs.branch { return false }
        if lhs.buildDate != rhs.buildDate { return false }
        if lhs.buildUser != rhs.buildUser { return false }
        if lhs.estimatedHeight != rhs.estimatedHeight { return false }
        if lhs.zcashdBuild != rhs.zcashdBuild { return false }
        if lhs.zcashdSubversion != rhs.zcashdSubversion { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension TransparentAddressBlockFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TransparentAddressBlockFilter"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "range"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &address)
            case 2: try decoder.decodeSingularMessageField(value: &_range)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !address.isEmpty {
            try visitor.visitSingularStringField(value: address, fieldNumber: 1)
        }
        try { if let v = self._range {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: TransparentAddressBlockFilter, rhs: TransparentAddressBlockFilter) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs._range != rhs._range { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Duration"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "intervalUs"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &intervalUs)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if intervalUs != 0 {
            try visitor.visitSingularInt64Field(value: intervalUs, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Duration, rhs: Duration) -> Bool {
        if lhs.intervalUs != rhs.intervalUs { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PingResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entry"),
        2: .same(proto: "exit"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &entry)
            case 2: try decoder.decodeSingularInt64Field(value: &exit)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if entry != 0 {
            try visitor.visitSingularInt64Field(value: entry, fieldNumber: 1)
        }
        if exit != 0 {
            try visitor.visitSingularInt64Field(value: exit, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: PingResponse, rhs: PingResponse) -> Bool {
        if lhs.entry != rhs.entry { return false }
        if lhs.exit != rhs.exit { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Address"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &address)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularStringField(value: address, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Address, rhs: Address) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension AddressList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AddressList"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedStringField(value: &addresses)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !addresses.isEmpty {
            try visitor.visitRepeatedStringField(value: addresses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: AddressList, rhs: AddressList) -> Bool {
        if lhs.addresses != rhs.addresses { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Balance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Balance"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "valueZat"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &valueZat)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if valueZat != 0 {
            try visitor.visitSingularInt64Field(value: valueZat, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Balance, rhs: Balance) -> Bool {
        if lhs.valueZat != rhs.valueZat { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Exclude: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Exclude"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "txid"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedBytesField(value: &txid)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !txid.isEmpty {
            try visitor.visitRepeatedBytesField(value: txid, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Exclude, rhs: Exclude) -> Bool {
        if lhs.txid != rhs.txid { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension TreeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TreeState"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "network"),
        2: .same(proto: "height"),
        3: .same(proto: "hash"),
        4: .same(proto: "time"),
        5: .same(proto: "saplingTree"),
        6: .same(proto: "orchardTree"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &network)
            case 2: try decoder.decodeSingularUInt64Field(value: &height)
            case 3: try decoder.decodeSingularStringField(value: &hash)
            case 4: try decoder.decodeSingularUInt32Field(value: &time)
            case 5: try decoder.decodeSingularStringField(value: &saplingTree)
            case 6: try decoder.decodeSingularStringField(value: &orchardTree)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !network.isEmpty {
            try visitor.visitSingularStringField(value: network, fieldNumber: 1)
        }
        if height != 0 {
            try visitor.visitSingularUInt64Field(value: height, fieldNumber: 2)
        }
        if !hash.isEmpty {
            try visitor.visitSingularStringField(value: hash, fieldNumber: 3)
        }
        if time != 0 {
            try visitor.visitSingularUInt32Field(value: time, fieldNumber: 4)
        }
        if !saplingTree.isEmpty {
            try visitor.visitSingularStringField(value: saplingTree, fieldNumber: 5)
        }
        if !orchardTree.isEmpty {
            try visitor.visitSingularStringField(value: orchardTree, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: TreeState, rhs: TreeState) -> Bool {
        if lhs.network != rhs.network { return false }
        if lhs.height != rhs.height { return false }
        if lhs.hash != rhs.hash { return false }
        if lhs.time != rhs.time { return false }
        if lhs.saplingTree != rhs.saplingTree { return false }
        if lhs.orchardTree != rhs.orchardTree { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension GetSubtreeRootsArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSubtreeRootsArg"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "startIndex"),
        2: .same(proto: "shieldedProtocol"),
        3: .same(proto: "maxEntries"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &startIndex)
            case 2: try decoder.decodeSingularEnumField(value: &shieldedProtocol)
            case 3: try decoder.decodeSingularUInt32Field(value: &maxEntries)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if startIndex != 0 {
            try visitor.visitSingularUInt32Field(value: startIndex, fieldNumber: 1)
        }
        if shieldedProtocol != .sapling {
            try visitor.visitSingularEnumField(value: shieldedProtocol, fieldNumber: 2)
        }
        if maxEntries != 0 {
            try visitor.visitSingularUInt32Field(value: maxEntries, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: GetSubtreeRootsArg, rhs: GetSubtreeRootsArg) -> Bool {
        if lhs.startIndex != rhs.startIndex { return false }
        if lhs.shieldedProtocol != rhs.shieldedProtocol { return false }
        if lhs.maxEntries != rhs.maxEntries { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension SubtreeRoot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubtreeRoot"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "rootHash"),
        3: .same(proto: "completingBlockHash"),
        4: .same(proto: "completingBlockHeight"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try decoder.decodeSingularBytesField(value: &rootHash)
            case 3: try decoder.decodeSingularBytesField(value: &completingBlockHash)
            case 4: try decoder.decodeSingularUInt64Field(value: &completingBlockHeight)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !rootHash.isEmpty {
            try visitor.visitSingularBytesField(value: rootHash, fieldNumber: 2)
        }
        if !completingBlockHash.isEmpty {
            try visitor.visitSingularBytesField(value: completingBlockHash, fieldNumber: 3)
        }
        if completingBlockHeight != 0 {
            try visitor.visitSingularUInt64Field(value: completingBlockHeight, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: SubtreeRoot, rhs: SubtreeRoot) -> Bool {
        if lhs.rootHash != rhs.rootHash { return false }
        if lhs.completingBlockHash != rhs.completingBlockHash { return false }
        if lhs.completingBlockHeight != rhs.completingBlockHeight { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension GetAddressUtxosArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetAddressUtxosArg"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
        2: .same(proto: "startHeight"),
        3: .same(proto: "maxEntries"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedStringField(value: &addresses)
            case 2: try decoder.decodeSingularUInt64Field(value: &startHeight)
            case 3: try decoder.decodeSingularUInt32Field(value: &maxEntries)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !addresses.isEmpty {
            try visitor.visitRepeatedStringField(value: addresses, fieldNumber: 1)
        }
        if startHeight != 0 {
            try visitor.visitSingularUInt64Field(value: startHeight, fieldNumber: 2)
        }
        if maxEntries != 0 {
            try visitor.visitSingularUInt32Field(value: maxEntries, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: GetAddressUtxosArg, rhs: GetAddressUtxosArg) -> Bool {
        if lhs.addresses != rhs.addresses { return false }
        if lhs.startHeight != rhs.startHeight { return false }
        if lhs.maxEntries != rhs.maxEntries { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension GetAddressUtxosReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetAddressUtxosReply"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        6: .same(proto: "address"),
        1: .same(proto: "txid"),
        2: .same(proto: "index"),
        3: .same(proto: "script"),
        4: .same(proto: "valueZat"),
        5: .same(proto: "height"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &txid)
            case 2: try decoder.decodeSingularInt32Field(value: &index)
            case 3: try decoder.decodeSingularBytesField(value: &script)
            case 4: try decoder.decodeSingularInt64Field(value: &valueZat)
            case 5: try decoder.decodeSingularUInt64Field(value: &height)
            case 6: try decoder.decodeSingularStringField(value: &address)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !txid.isEmpty {
            try visitor.visitSingularBytesField(value: txid, fieldNumber: 1)
        }
        if index != 0 {
            try visitor.visitSingularInt32Field(value: index, fieldNumber: 2)
        }
        if !script.isEmpty {
            try visitor.visitSingularBytesField(value: script, fieldNumber: 3)
        }
        if valueZat != 0 {
            try visitor.visitSingularInt64Field(value: valueZat, fieldNumber: 4)
        }
        if height != 0 {
            try visitor.visitSingularUInt64Field(value: height, fieldNumber: 5)
        }
        if !address.isEmpty {
            try visitor.visitSingularStringField(value: address, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: GetAddressUtxosReply, rhs: GetAddressUtxosReply) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.txid != rhs.txid { return false }
        if lhs.index != rhs.index { return false }
        if lhs.script != rhs.script { return false }
        if lhs.valueZat != rhs.valueZat { return false }
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension GetAddressUtxosReplyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetAddressUtxosReplyList"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addressUtxos"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &addressUtxos)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !addressUtxos.isEmpty {
            try visitor.visitRepeatedMessageField(value: addressUtxos, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: GetAddressUtxosReplyList, rhs: GetAddressUtxosReplyList) -> Bool {
        if lhs.addressUtxos != rhs.addressUtxos { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
